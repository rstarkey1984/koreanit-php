# 🕸️ 웹( Web )이란 무엇인가?

### **웹(Web)** 은 "**월드 와이드 웹( WWW, World Wide Web )**"의 줄임말로,
### 인터넷을 통해 사람들이 정보를 **주고받고 공유**할 수 있는 **정보시스템** 입니다.

-   **인터넷( Internet )** : 전 세계의 컴퓨터가 연결된 네트워크
-   **웹( Web )** : 인터넷 위에서 작동하는 여러 서비스 중 하나 ( 다른 서비스로는 이메일, 파일전송(FTP), 원격접속(SSH) 등 )

-  우리가 주로 사용하는 웹사이트(유튜브,블로그 등) 와 웹개발에서 널리 쓰이는 API 서비스 (REST, GraphQL 등) 가 웹의 한 형태

## 1. 웹의 기본 구조 ( 클라이언트-서버 모델 )

### 웹은 **클라이언트( Client )** 와 **서버( Server )** 의 상호작용으로 작동합니다.

![클라이언트-서버 모델](https://lh3.googleusercontent.com/d/1WLg2EsUfIrPKtyEdvk1Oh6E98hp-KI3v)

### 💻 클라이언트( Client )

-   브라우저 ( 크롬, 엣제, 사파리 등 )
-   서버에 정보를 **요청(request)** 하는 역할
-   예: "구글 홈페이지를 열어줘!"

### 🖥 서버( Server )

-   웹서버 ( Nginx, Apache, Tomcat 등 )
-   클라이언트의 요청에 **응답(response)** 하여 결과를 보냄
-   예: "여기 구글 메인 HTML을 보냅니다!"


## 2. 브라우저에서 `www.google.com` 을 입력했을 때의 전체 흐름

### 1️⃣ URL 입력

사용자가 브라우저 주소창에 `www.google.com` 을 입력하면, 브라우저는 이것이 **도메인 이름**이라는 것을 인식합니다.

`https://` 가 생략되어 있다면 기본적으로 HTTPS(443번 포트)를 사용합니다.


### 2️⃣ DNS 조회 ( Domain Name System )

브라우저는 서버와 실제 통신을 위해 **IP 주소**가 필요하므로 찾기 위해 다음 단계를 진행합니다.

1. 브라우저(크롬,엣지,사파리 등) 캐시 확인 → 예전에 방문한 적 있나?
2. OS 캐시 (hosts 파일 포함) 확인 → 로컬에서 설정된 IP 있나?
3. ISP(통신사)의 DNS 서버 에 질의(Query)
4. 없으면 루트 DNS 서버 ( Root Name Server ) → `.com` 서버 ( TLD 네임서버 ) → `google.com` 네임서버 ( Authoritative(권한) 네임서버 ) 순으로 찾아서 결과적으로 권한 네임서버에 등록된 IP 주소를 받습니다.   

    💡 이 IP 주소는 DNS 캐시 에 저장되어 다음에 더 빠르게 접근합니다.

- 대표적인 권한 네임서버 서비스 하는곳 : AWS Route 53, Google Cloud DNS, KISA 네임서버 등

### 3️⃣ TCP 연결 ( 3-way Handshake )

이제 브라우저(클라이언트)는 IP 주소를 알았으니 서버와 TCP 연결을 맺습니다.

| 단계    | 동작   | 설명                        |
|:---:|--- | ------------------------- | 
|  1| SYN   | 클라이언트 → 서버 : “연결하고 싶어요”   |    
| 2| SYN-ACK | 서버 → 클라이언트 : “좋아요, 준비됐어요” |    
| 3 | ACK  | 클라이언트 → 서버 : “확인했습니다”     |    

이 과정을 **3-way handshake** 라고 하며 이 과정이 끝이 나면 TCP 레벨에서 양방향 통신 가능한 파이프라인(소켓)이 생성

- SYN = Synchronize : “연결을 시작하자” — TCP 시퀀스 번호 초기화용
- ACK = Acknowledge : “잘 받았어” — 상대의 요청이나 데이터 수신 확인

### 4️⃣ TLS(SSL) 핸드셰이크 ( HTTPS인 경우 )

구글은 HTTPS(보안 프로토콜)을 사용하므로, TCP 연결 위에서 데이터를 암호화해서 흘려보내기 위해 아래 단계를 진행합니다.
| 단계    |  설명                        |
|:---:|------------------------ | 
|  1| 브라우저가 “나 TLS 쓸게요!” (버전, 암호화 방식 등)  |    
| 2| 서버가 “좋아, 내 인증서 여기 있어” (공개키 포함) |    
| 3 |  브라우저가 인증서를 검증 (CA 서명 확인, 도메인 일치 확인 등)     |    
| 4 |  이후 공개키 기반 암호화로 대칭키 교환     |    
| 5 |  보안 채널(암호화된 TCP 연결) 완성    |    

🔒 이후 통신은 모두 암호화되어 주고받습니다 

### 5️⃣ 클라이언트의 요청 ( HTTP Request )

브라우저는 이제 암호화된 채널을 통해 HTTP 프로토콜로 요청을 보냅니다.

클라이언트가 서버에 보내는 메시지는 아래와 같이 구성됩니다.
```
Request Line → 요청 라인 (또는 상태 라인)
Headers → 여러 개의 헤더들
---빈 줄 하나---
Body → 실제 데이터 (POST나 PUT일 때만 존재)
```

클라이언트 요청( GET ) 예시:
```
<!-- Request Line -->
GET / HTTP/1.1
<!-- Headers 시작 -->
Host: www.google.com
Connection: keep-alive
User-Agent: Chrome/129.0 - 
Accept: text/html,application/xhtml+xml
Accept-Language: ko-KR
Cookie: sessionid=abcd1234
Authorization: Bearer eyJhbGciOiJI...
<!-- Headers 끝 -->

<!-- Body 시작 --> (POST나 PUT일 때만 존재)
username=student01&password=1234
<!-- Body 끝 -->
```

- Request Line ( 요청 라인 ) : 요청의 첫 줄로, 어떤 행동을 할지와 대상 주소를 알려줍니다.
    |항목|의미|
    |------|---|
    |GET|요청 메서드(행동)|
    |/|요청할 리소스(경로)|
    |HTTP/1.1|프로토콜 버전|

- Headers : 클라이언트(브라우저나 앱)가 자신의 환경, 요청 세부 정보, 인증 정보 등을 보냅니다. 서버는 이걸 보고 “누가, 어떻게 요청했는지” 판단합니다.

    |헤더|설명|
    |------|---|
    |Host|	요청 대상 도메인 이름 (www.google.com)|
    |Connection| keep-alive 면 TCP 연결을 한 번 맺은 후, 여러 HTTP 요청을 같은 연결로 재사용하겠다는 뜻|
    |User-Agent	|클라이언트 종류 (브라우저, OS 정보 등)|
    |Accept	|클라이언트가 받을 수 있는 콘텐츠 형식|
    |Accept-Language|	선호하는 언어|
    |Referer	|이전 페이지 URL (어디서 왔는지)|
    |Cookie|세션이나 로그인 정보|
    |Authorization|	인증 토큰 또는 자격 증명|
    |Content-Type|(POST 요청 시) 보낸 데이터 형식 (예: application/json)|


- Body( 본문 ) : 
    |메서드|설명|
    |------|---|
    |GET | 보통 없음. |
    |POST / PUT / PATCH | 데이터가 본문에 담겨서 전송 (예: username=student01&password=1234 )|

### 6️⃣ 서버의 응답 ( HTTP Response )

서버의 HTTP 응답 메시지는 이렇게 구성됩니다.
```
Response Line → 응답 라인 (또는 상태 라인)
Headers → 여러 개의 헤더들
---빈 줄 하나---
Body → 실제 데이터
```

서버 응답 예시:
```
<!-- Response Line -->
HTTP/1.1 200 OK 
<!-- Headers 시작 -->
Content-Type: text/html
Content-Length: 1234
Connection: keep-alive
Keep-Alive: timeout=5, max=100
<!-- Headers 끝 -->

<!-- Body 시작 -->
<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>
<!-- Body 끝 -->
```
- Response Line( 응답 라인 ) : 서버가 클라이언트의 요청을 처리한 후, 그 결과를 처음 한 줄에 요약해서 보내는 부분입니다.
    |항목|설명|
    |---|---|
    |HTTP/1.1	|사용 중인 프로토콜 버전|
    |	200|	요청 처리 결과를 나타내는 숫자|
    |	OK	|상태코드의 의미를 사람이 읽기 쉽게 표현|

- Headers : 본문( body ) 에 대한 설명 정보

    |헤더|	설명|
    |---|---|
    |Content-Type|Body 데이터 형식|
    |Content-Length|Body 데이터 길이|
    |Connection| keep-alive	라면 연결을 유지하겠다는 뜻 (서버도 동의)|
    |Keep-Alive| timeout=5, max=100	옵션 헤더 — 얼마나 유지할지 조건 지정|
    |timeout|	연결을 몇 초 동안 유지할지 (예: 5초 동안 다음 요청 기다림)|
    |max|	한 연결에서 몇 개의 요청까지 처리할지 제한|

- Body( 본문 ) : 본문에는 **HTML 코드**가 담겨 있습니다. 


### 7️⃣ 렌더링(Rendering)

브라우저는 받은 HTML을 파싱하여 DOM(Document Object Model)을 만들고, CSS를 적용해 스타일을 입히고 JS를 실행시켜 동적 기능을 구현합니다.


위와 같은 이 과정을 통해 **화면에 구글 홈페이지가 표시됩니다.**

--- 

## 요약정리

단계별로 간단히 정리하자면 다음과 같습니다.

| 단계 | 이름 | 설명 |
|------|------|------|
| 1 | URL 입력 | 도메인 이름을 인식 |
| 2 | DNS 조회 | 도메인을 IP 주소로 변환 |
| 3 | TCP 연결 | 서버와 통신 채널 생성  |
| 4 | TLS 설정 | 데이터를 암호화 ( HTTPS 일때 ) |
| 5 | HTTP 요청 | 서버에 페이지 요청 |
| 6 | HTTP 응답 | 서버가 HTML/CSS/JS 반환 |
| 7 | 렌더링 | 브라우저가 화면 구성 |

> 브라우저 주소창에 URL을 입력하는 단순한 행위는  
> 사실상 수십 개의 네트워크, 보안, 프로토콜 과정이 순식간에 일어나는 결과입니다.


## 🔍 크롬 개발자 도구로 확인하기

- 크롬을 실행해서 http://www.google.com 에 접속 후 F12를 눌러 **Network 탭**에서 브라우저가 서버에 요청하는 값들과 서버에서 응답한 값들을 아래와 같이 직접 볼 수 있습니다.
![크롬개발자도구](https://lh3.googleusercontent.com/d/1S82-pXRZAIwd5rol4VQ2COdeXkxjYzhP)

- Headers : 클라이언트와 서버가 주고받는 정보를 확인할 수 있습니다.
- Preview : 서버가 응답해준 데이터 미리보기
- Response : 서버가 응답한 Body( 본문 )
- Cookies : 클라이언트와 서버가 주고받은 Header 안에 있는 쿠키정보를 보기 쉽게 표로 확인할 수 있음.

